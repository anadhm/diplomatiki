
xdp_prog_kern.o:	file format elf64-bpf

Disassembly of section xdp_morton_filter:

0000000000000000 <xdp_morton_filter_func>:
; {
       0:	r6 = 1
; 	void *data_end = (void *)(long)ctx->data_end;
       1:	r2 = *(u32 *)(r1 + 4)
; 	void *data = (void *)(long)ctx->data;
       2:	r1 = *(u32 *)(r1 + 0)
; 	if (eth + 1 > data_end){
       3:	r3 = r1
       4:	r3 += 14
       5:	if r3 > r2 goto +37 <LBB0_5>
; 	if (bpf_ntohs(eth->h_proto) != ETH_P_IP){
       6:	r3 = *(u8 *)(r1 + 12)
       7:	r4 = *(u8 *)(r1 + 13)
       8:	r4 <<= 8
       9:	r4 |= r3
      10:	if r4 != 8 goto +32 <LBB0_5>
; 	if (iph + 1 > data_end){
      11:	r3 = r1
      12:	r3 += 34
      13:	if r3 > r2 goto +29 <LBB0_5>
; 	if (iph->protocol != IPPROTO_ICMP){
      14:	r1 = *(u8 *)(r1 + 23)
      15:	if r1 == 1 goto +1 <LBB0_6>
      16:	goto +26 <LBB0_5>

0000000000000088 <LBB0_6>:
      17:	r6 = 0
; 	__u32 block1 = glbi1/BUCKETS_PER_BLOCK; //should be integer division
      18:	*(u32 *)(r10 - 4) = r6
; 	block=bpf_map_lookup_elem(&morton_filter,&block1);
      19:	r7 = 0 ll
      21:	r2 = r10
      22:	r2 += -4
; 	block=bpf_map_lookup_elem(&morton_filter,&block1);
      23:	r1 = 0 ll
      25:	call 1
; 	if (!block){
      26:	if r0 == 0 goto +16 <LBB0_5>
      27:	r1 = *(u32 *)(r7 + 12)
; 	if (!block){
      28:	if r1 > 55 goto +1 <LBB0_4>
      29:	goto +13 <LBB0_5>

00000000000000f0 <LBB0_4>:
      30:	r1 = 117
; 	bpf_printk("prob index:%u",(FSA_ARRAY_END + lbi1*FCA_BITS)>>3);
      31:	*(u16 *)(r10 - 12) = r1
      32:	r1 = 624588901
      33:	*(u32 *)(r10 - 16) = r1
      34:	r1 = 7236837239042306672 ll
      36:	*(u64 *)(r10 - 24) = r1
      37:	r1 = r10
      38:	r1 += -24
      39:	r2 = 14
      40:	r3 = 55
      41:	call 6
      42:	r6 = 1

0000000000000158 <LBB0_5>:
; }
      43:	r0 = r6
      44:	exit
